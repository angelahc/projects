---
title: "Feature Engineering"
output: html_document
author: Angela He Chen
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
install.packages("rJava")
library(ggplot2)
library(plyr)
library(dplyr)
library(moments)
library(glmnet)
library(caret)
library(car)
dyn.load("/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home/lib/server/libjvm.dylib")
library(FSelector)
```


```{r loading the train and test data}
setwd("/Users/angelahc/Documents/Feature Engineering Projects")
training_data = read.csv("train.csv", sep=',')
training_data
test_data = read.csv("test.csv", sep=',')
test_data
```


#Initial Data Undestanding and Data Cleaning

```{r Check for duplicates}
length(unique(training_data$Id)) == nrow(training_data)
```

There is no duplicates so we remove the Id column
```{r Remove the ID Column}
training_data = training_data[ , -which(names(training_data) %in% c("Id"))]
```


# Hunting NAs
The dataset is filled with many missing values, therefore, before we can build any predictive model we have to clean our data by filling in all NA's with appropriate values.

Counting columns with null values:
```{r NAs discovery}
na.cols <- which(colSums(is.na(training_data)) > 0)
sort(colSums(sapply(training_data[na.cols], is.na)), decreasing = TRUE)
paste('There are', length(na.cols), 'columns with missing values')
```

NA imputation:
```{r Train NA Imputation}
# Alley : NA means "no alley access according to field description
training_data$Alley = factor(training_data$Alley, levels=c(levels(training_data$Alley), "None"))
training_data$Alley[is.na(training_data$Alley)] = "None"

training_data$BedroomAbvGr[is.na(training_data$BedroomAbvGr)] <- 0

# Bsmt : NA for basement features is "no basement" according to field description
# Every field related to basement and there is an NA, we input 'No' to express that there is no basement to begin with. 
training_data$BsmtQual = factor(training_data$BsmtQual, levels=c(levels(training_data$BsmtQual), "No"))
training_data$BsmtQual[is.na(training_data$BsmtQual)] = "No"

training_data$BsmtCond = factor(training_data$BsmtCond, levels=c(levels(training_data$BsmtCond), "No"))
training_data$BsmtCond[is.na(training_data$BsmtCond)] = "No"

training_data$BsmtExposure[is.na(training_data$BsmtExposure)] = "No"

training_data$BsmtFinType1 = factor(training_data$BsmtFinType1, levels=c(levels(training_data$BsmtFinType1), "No"))
training_data$BsmtFinType1[is.na(training_data$BsmtFinType1)] = "No"

training_data$BsmtFinType2 = factor(training_data$BsmtFinType2, levels=c(levels(training_data$BsmtFinType2), "No"))
training_data$BsmtFinType2[is.na(training_data$BsmtFinType2)] = "No"

# Fence : NA means "no fence" according to field description
training_data$Fence = factor(training_data$Fence, levels=c(levels(training_data$Fence), "No"))
training_data$Fence[is.na(training_data$Fence)] = "No"

# FireplaceQu : NA means "no fireplace" according to field description
training_data$FireplaceQu = factor(training_data$FireplaceQu, levels=c(levels(training_data$FireplaceQu), "No"))
training_data$FireplaceQu[is.na(training_data$FireplaceQu)] = "No"

# Garage : NA for garage features is "no garage" according to field description
# Every field related to Garage and there is an NA, we input 'No' to express that there is no garage to begin with
training_data$GarageType = factor(training_data$GarageType, levels=c(levels(training_data$GarageType), "No"))
training_data$GarageType[is.na(training_data$GarageType)] = "No"

training_data$GarageFinish = factor(training_data$GarageFinish, levels=c(levels(training_data$GarageFinish), "No"))
training_data$GarageFinish[is.na(training_data$GarageFinish)] = "No"

training_data$GarageQual = factor(training_data$GarageQual, levels=c(levels(training_data$GarageQual), "No"))
training_data$GarageQual[is.na(training_data$GarageQual)] = "No"

training_data$GarageCond = factor(training_data$GarageCond, levels=c(levels(training_data$GarageCond), "No"))
training_data$GarageCond[is.na(training_data$GarageCond)] = "No"

# LotFrontage : NA would most likely means no lot frontage
training_data$LotFrontage[is.na(training_data$LotFrontage)] <- 0

# MasVnrType and MasVnrArea : NA most likely means no mansory veneer
training_data$MasVnrType[is.na(training_data$MasVnrType)] = "None"
training_data$MasVnrArea[is.na(training_data$MasVnrArea)] <- 0

# PoolQC : data description says NA means "no pool"
training_data$PoolQC = factor(training_data$PoolQC, levels=c(levels(training_data$PoolQC), "No"))
training_data$PoolQC[is.na(training_data$PoolQC)] = "No"

# MiscFeature : NA = "no misc feature" according to field description
training_data$MiscFeature = factor(training_data$MiscFeature, levels=c(levels(training_data$MiscFeature), "No"))
training_data$MiscFeature[is.na(training_data$MiscFeature)] = "No"

# Electrical : NA means "UNK"
training_data$Electrical = factor(training_data$Electrical, levels=c(levels(training_data$Electrical), "UNK"))
training_data$Electrical[is.na(training_data$Electrical)] = "UNK"

# GarageYrBlt is removed. Some houses do not have a garage
# therefore, it does not make sense to replace NA with the Year Built
training_data$GarageYrBlt<-NULL
# Utilities is also removed because it only contains one unique value so it's not so informative.
training_data$Utilities<-NULL
```


```{r confirming there is no NA anymore}
na.cols <- which(colSums(is.na(training_data)) > 0)
training_data[na.cols]
paste('There are now', length(na.cols), 'column with missing values')
```

We repeat the process for test_data
```{r Test NA Imputation, same procedure as the training data}
# Alley : data description says NA means "no alley access"
test_data$Alley = factor(test_data$Alley, levels=c(levels(test_data$Alley), "None"))
test_data$Alley[is.na(test_data$Alley)] = "None"

test_data$BedroomAbvGr[is.na(test_data$BedroomAbvGr)] <- 0

# BsmtQual etc : data description says NA for basement features is "no basement"
test_data$BsmtQual = factor(test_data$BsmtQual, levels=c(levels(test_data$BsmtQual), "No"))
test_data$BsmtQual[is.na(test_data$BsmtQual)] = "No"

test_data$BsmtCond = factor(test_data$BsmtCond, levels=c(levels(test_data$BsmtCond), "No"))
test_data$BsmtCond[is.na(test_data$BsmtCond)] = "No"

test_data$BsmtExposure[is.na(test_data$BsmtExposure)] = "No"

test_data$BsmtFinType1 = factor(test_data$BsmtFinType1, levels=c(levels(test_data$BsmtFinType1), "No"))
test_data$BsmtFinType1[is.na(test_data$BsmtFinType1)] = "No"

test_data$BsmtFinType2 = factor(test_data$BsmtFinType2, levels=c(levels(test_data$BsmtFinType2), "No"))
test_data$BsmtFinType2[is.na(test_data$BsmtFinType2)] = "No"

# Fence : data description says NA means "no fence"
test_data$Fence = factor(test_data$Fence, levels=c(levels(test_data$Fence), "No"))
test_data$Fence[is.na(test_data$Fence)] = "No"

# FireplaceQu : data description says NA means "no fireplace"
test_data$FireplaceQu = factor(test_data$FireplaceQu, levels=c(levels(test_data$FireplaceQu), "No"))
test_data$FireplaceQu[is.na(test_data$FireplaceQu)] = "No"

# GarageType etc : data description says NA for garage features is "no garage"
test_data$GarageType = factor(test_data$GarageType, levels=c(levels(test_data$GarageType), "No"))
test_data$GarageType[is.na(test_data$GarageType)] = "No"

test_data$GarageFinish = factor(test_data$GarageFinish, levels=c(levels(test_data$GarageFinish), "No"))
test_data$GarageFinish[is.na(test_data$GarageFinish)] = "No"

test_data$GarageQual = factor(test_data$GarageQual, levels=c(levels(test_data$GarageQual), "No"))
test_data$GarageQual[is.na(test_data$GarageQual)] = "No"

test_data$GarageCond = factor(test_data$GarageCond, levels=c(levels(test_data$GarageCond), "No"))
test_data$GarageCond[is.na(test_data$GarageCond)] = "No"

# LotFrontage : NA most likely means no lot frontage
test_data$LotFrontage[is.na(test_data$LotFrontage)] <- 0

# MasVnrType : NA most likely means no veneer
test_data$MasVnrType[is.na(test_data$MasVnrType)] = "None"
test_data$MasVnrArea[is.na(test_data$MasVnrArea)] <- 0

# PoolQC : data description says NA means "no pool"
test_data$PoolQC = factor(test_data$PoolQC, levels=c(levels(test_data$PoolQC), "No"))
test_data$PoolQC[is.na(test_data$PoolQC)] = "No"

# MiscFeature : data description says NA means "no misc feature"
test_data$MiscFeature = factor(test_data$MiscFeature, levels=c(levels(test_data$MiscFeature), "No"))
test_data$MiscFeature[is.na(test_data$MiscFeature)] = "No"

# GarageYrBlt is removed. Some houses do not have a garage. Same as training data.
test_data$GarageYrBlt<-NULL
# Utilities is not so information since it only has one unique value.
test_data$Utilities<-NULL
```


```{r removing outliners manually}
# Here we plot the independent variable versus SalePrice to see what outliner we should manually remove.
# Removing outliners using quantile was used before, but it didn't yield best results.
plot(training_data$GrLivArea, training_data$SalePrice)
training_data<-training_data[training_data$GrLivArea<3200, ]
plot(training_data$GrLivArea, training_data$SalePrice)

plot(training_data$GarageArea, training_data$SalePrice)
training_data<-training_data[training_data$GarageArea<1150, ]
plot(training_data$GarageArea, training_data$SalePrice)

plot(training_data$YearBuilt, training_data$SalePrice)
training_data<-training_data[training_data$YearBuilt>1900, ]

plot(training_data$X1stFlrSF, training_data$SalePrice)
training_data<-training_data[training_data$X1stFlrSF<2200, ]

plot(training_data$TotalBsmtSF, training_data$SalePrice)
training_data<-training_data[training_data$TotalBsmtSF<2100, ]
```

#Skewness
```{r checking for skewness}
df <- rbind(data.frame(version="log(price+1)",x=log(training_data$SalePrice + 1)),
            data.frame(version="price",x=training_data$SalePrice))

ggplot(data=df) +
  facet_wrap(~version,ncol=2,scales="free_x") +
  geom_histogram(aes(x=x), bins = 50)
```

We take log of the SalePrice:
```{r}
training_data$SalePrice <- log1p(training_data$SalePrice)
```


I tried normalizing the variables using tranformation based on certain criteria of skewness; however, my model worsened. So, I just log the SalePrice.
```{r}
#column_types <- sapply(names(training_data),function(x){class(training_data[[x]])})
#numeric_columns <-names(column_types[column_types != "factor"])

# skew of each variable
#skew <- sapply(numeric_columns,function(x){skewness(training_data[[x]],na.rm = T)})

# transform all variables above a threshold skewness.
#skew <- skew[skew > 0.75]
#for(x in names(skew)) {
  #training_data[[x]] <- log(training_data[[x]] + 1)
#}
```

For the test data
```{r}
#column_types <- sapply(names(test_data),function(x){class(test_data[[x]])})
#numeric_columns <-names(column_types[column_types != "factor"])

#skew <- sapply(numeric_columns,function(x){skewness(test_data[[x]],na.rm = T)})
#skew <- skew[skew > 0.75]
#for(x in names(skew)) {
  #test_data[[x]] <- log(test_data[[x]] + 1)
#}
```


```{r transformations and creating new features}
# 2007-2009 were the house price declined due to the bubble.
# these years are separated from the others to account for their macroeconomic impact.
training_try<-training_data
# training_try was originally created so that training_data remained intact in case of big errors. However, we will keep using it because otherwise there will be timing-consuming modifications on codes.

training_try$YearSold[training_try$YrSold == 2007 | training_try$YrSold == 2008 | training_try$YrSold == 2009] <- 1
training_try$YearSold[is.na(training_try$YearSold)] <- 0

# Porch and Pool are nice adds on to the house. The size probably will not matter as much
# The fact that a house has one of these matters
training_try$WoodDeckSF[training_try$WoodDeckSF != 0] <-1
training_try$OpenPorchSF[training_try$OpenPorchSF != 0] <-1
training_try$EnclosedPorch[training_try$EnclosedPorch != 0] <-1
training_try$X3SsnPorch[training_try$X3SsnPorch != 0] <-1
training_try$ScreenPorch[training_try$ScreenPorch != 0] <-1
training_try$PoolArea[training_try$PoolArea != 0] <-1

# Identifying the newer dwellings
training_try$Newer[training_try$MSSubClass == 20 | training_try$MSSubClass == 60 | training_try$MSSubClass == 120 | training_try$MSSubClass == 160] <- 1
training_try$Newer[is.na(training_try$Newer)] <- 0

# We convert as many variables into numeric as possible.
# As regression works better with numeric variable.
training_try$Street <- ifelse(training_try$Street %in% c('Grvl'), 1, 0)

training_try$Alley <- ifelse(training_try$Alley %in% c('Grvl' , 'Pave'), 1, 0)

training_try$LotShape <- ifelse(training_try$LotShape %in% c('Reg'), 1, 0)

training_try$PavedDrive <- ifelse(training_try$PavedDrive %in% c('Y' , 'P'), 1, 0)


#https://www.neighborhoodscout.com/ia/ames
# Some neighborhoods are more experience and better than others.
# Research was done using the link provided above to select the good neighborhoods in Ames, IOWA.
training_try$Neighborhood <- ifelse(training_try$Neighborhood %in% c('NoRidge','NridgHt', 'StoneBr', 'SWISU', 'Somerst', 'Timber', 'Veenker'), 1, 0)


# Averaging the scores: overall quality and overall condition
training_try$OverallRate<- (training_try$OverallQual+training_try$OverallCond)/2

# The intuition behind why there is a separation between good and bad rate is that good rate normally rises the price and bad rate usually lowers the price.
training_try$Good_Rate<- training_try$OverallRate
training_try$Good_Rate[training_try$Good_Rate >= 8] <- 1
training_try$Good_Rate[training_try$Good_Rate != 1] <- 0

training_try$Bad_Rate<- training_try$OverallRate
training_try$Bad_Rate[training_try$Bad_Rate < 2] <- 1
training_try$Bad_Rate[training_try$Bad_Rate != 1] <- 0

# YearRemodAdd will express where or not a house has been remodelled. 
#Older but remodelled is believed to worth a bit more.
training_try$YearRemodAdd[training_try$YearRemodAdd == training_try$YearBuilt] <- 0
training_try$YearRemodAdd[training_try$YearRemodAdd != 0] <- 1

# Transform ExterQual into numeric
training_try$ExterQual <- sapply(training_try$ExterQual, as.character)
training_try$ExterQual[training_try$ExterQual == 'Ex'] <- '5'
training_try$ExterQual[training_try$ExterQual == 'Gd'] <- '4'
training_try$ExterQual[training_try$ExterQual == 'TA'] <- '3'
training_try$ExterQual[training_try$ExterQual == 'Fa'] <- '2'
training_try$ExterQual[training_try$ExterQual == 'Po'] <- '1'
training_try$ExterQual<-as.numeric(training_try$ExterQual)

# The intuition behind why there is a separation between good and bad Exterior Quality is that good quality normally rises the price and bad quality usually lowers the price.
training_try$Good_ExterQual<- training_try$ExterQual
training_try$Good_ExterQual[training_try$Good_ExterQual >= 4] <- 1
training_try$Good_ExterQual[training_try$Good_ExterQual != 1] <- 0

training_try$Bad_ExterQual<- training_try$ExterQual
training_try$Bad_ExterQual[training_try$Bad_ExterQual != 1] <- 0

# Transform ExterCond into numeric
training_try$ExterCond <- sapply(training_try$ExterCond, as.character)
training_try$ExterCond[training_try$ExterCond == 'Ex'] <- '5'
training_try$ExterCond[training_try$ExterCond == 'Gd'] <- '4'
training_try$ExterCond[training_try$ExterCond == 'TA'] <- '3'
training_try$ExterCond[training_try$ExterCond == 'Fa'] <- '2'
training_try$ExterCond[training_try$ExterCond == 'Po'] <- '1'
training_try$ExterCond<-as.numeric(training_try$ExterCond)

# Follows same intuition: good condition normally rises the price and bad condition usually lowers the price.
training_try$Good_ExterCond<- training_try$ExterCond
training_try$Good_ExterCond[training_try$Good_ExterCond >= 4] <- 1
training_try$Good_ExterCond[training_try$Good_ExterCond != 1] <- 0

training_try$Bad_ExterCond<- training_try$ExterCond
training_try$Bad_ExterCond[training_try$Bad_ExterCond != 1] <- 0

# Transform BsmtQual into numeric
training_try$BsmtQual <- sapply(training_try$BsmtQual, as.character)
training_try$BsmtQual[training_try$BsmtQual == 'Ex'] <- '5'
training_try$BsmtQual[training_try$BsmtQual == 'Gd'] <- '4'
training_try$BsmtQual[training_try$BsmtQual == 'TA'] <- '3'
training_try$BsmtQual[training_try$BsmtQual == 'Fa'] <- '2'
training_try$BsmtQual[training_try$BsmtQual == 'Po'] <- '1'
training_try$BsmtQual[training_try$BsmtQual == 'No'] <- '0'
training_try$BsmtQual<-as.numeric(training_try$BsmtQual)

# Follows same intuition: good quality normally rises the price and bad quality usually lowers the price.
training_try$Good_BsmtQual<- training_try$BsmtQual
training_try$Good_BsmtQual[training_try$Good_BsmtQual >= 4] <- 1
training_try$Good_BsmtQual[training_try$Good_BsmtQual != 1] <- 0

training_try$Bad_BsmtQual<- training_try$BsmtQual
training_try$Bad_BsmtQual[training_try$Bad_BsmtQual != 1] <- 0

# Transform BsmtCond into numeric
training_try$BsmtCond <- sapply(training_try$BsmtCond, as.character)
training_try$BsmtCond[training_try$BsmtCond == 'Ex'] <- '5'
training_try$BsmtCond[training_try$BsmtCond == 'Gd'] <- '4'
training_try$BsmtCond[training_try$BsmtCond == 'TA'] <- '3'
training_try$BsmtCond[training_try$BsmtCond == 'Fa'] <- '2'
training_try$BsmtCond[training_try$BsmtCond == 'Po'] <- '1'
training_try$BsmtCond[training_try$BsmtCond == 'No'] <- '0'
training_try$BsmtCond<-as.numeric(training_try$BsmtCond)

# Follows same intuition: good condition normally rises the price and bad condition usually lowers the price.
training_try$Good_BsmtCond<- training_try$BsmtCond
training_try$Good_BsmtCond[training_try$Good_BsmtCond >= 4] <- 1
training_try$Good_BsmtCond[training_try$Good_BsmtCond != 1] <- 0

training_try$Bad_BsmtCond<- training_try$BsmtCond
training_try$Bad_BsmtCond[training_try$Bad_BsmtCond != 1] <- 0

# Transform BsmtExposure into numeric
training_try$BsmtExposure <- sapply(training_try$BsmtExposure, as.character)
training_try$BsmtExposure[training_try$BsmtExposure == 'Gd'] <- '3'
training_try$BsmtExposure[training_try$BsmtExposure == 'Av'] <- '2'
training_try$BsmtExposure[training_try$BsmtExposure == 'Mn'] <- '1'
training_try$BsmtExposure[training_try$BsmtExposure == 'No'] <- '0'
training_try$BsmtExposure<-as.numeric(training_try$BsmtExposure)

# Transform BsmtFinType1 into numeric
training_try$BsmtFinType1 <- sapply(training_try$BsmtFinType1, as.character)
training_try$BsmtFinType1[training_try$BsmtFinType1 == 'GLQ'] <- '3'
training_try$BsmtFinType1[training_try$BsmtFinType1 == 'ALQ' | training_try$BsmtFinType1 == 'Rec'] <- '2'
training_try$BsmtFinType1[training_try$BsmtFinType1 == 'BLQ'] <- '1'
training_try$BsmtFinType1[training_try$BsmtFinType1 == 'LwQ' |training_try$BsmtFinType1 == 'Unf' | training_try$BsmtFinType1 == 'No'] <- '0'
training_try$BsmtFinType1<-as.numeric(training_try$BsmtFinType1)

# Transform BsmtFinType2 into numeric
training_try$BsmtFinType2 <- sapply(training_try$BsmtFinType2, as.character)
training_try$BsmtFinType2[training_try$BsmtFinType2 == 'GLQ'] <- '3'
training_try$BsmtFinType2[training_try$BsmtFinType2 == 'ALQ' | training_try$BsmtFinType2 == 'Rec'] <- '2'
training_try$BsmtFinType2[training_try$BsmtFinType2 == 'BLQ'] <- '1'
training_try$BsmtFinType2[training_try$BsmtFinType2 == 'LwQ' |training_try$BsmtFinType2 == 'Unf' | training_try$BsmtFinType2 == 'No'] <- '0'
training_try$BsmtFinType2<-as.numeric(training_try$BsmtFinType2)

# Transform CentralAir into numeric
training_try$CentralAir <- sapply(training_try$CentralAir, as.character)
training_try$CentralAir[training_try$CentralAir == 'Y'] <- '1'
training_try$CentralAir[training_try$CentralAir == 'N'] <- '0'
training_try$CentralAir<-as.numeric(training_try$CentralAir)

# Transform KitChenQual into numeric
training_try$KitchenQual <- sapply(training_try$KitchenQual, as.character)
training_try$KitchenQual[training_try$KitchenQual == 'Ex'] <- '4'
training_try$KitchenQual[training_try$KitchenQual == 'Gd'] <- '3'
training_try$KitchenQual[training_try$KitchenQual == 'TA'] <- '2'
training_try$KitchenQual[training_try$KitchenQual == 'Fa'] <- '1'
training_try$KitchenQual[training_try$KitchenQual == 'Po'] <- '0'
training_try$KitchenQual<-as.numeric(training_try$KitchenQual)

# Creating of 2 new variables follows same intuition: good quality normally rises the price and bad quality usually lowers the price.
training_try$Good_KitchenQual<- training_try$BsmtCond
training_try$Good_KitchenQual[training_try$Good_BsmtCond >= 3] <- 1
training_try$Good_KitchenQual[training_try$Good_BsmtCond != 1] <- 0

training_try$Bad_KitchenQual<- training_try$KitchenQual
training_try$Bad_KitchenQual[training_try$Bad_KitchenQual != 1] <- 0

# Transform HeatingQC into numeric
training_try$HeatingQC <- sapply(training_try$HeatingQC, as.character)
training_try$HeatingQC[training_try$HeatingQC == 'Ex'] <- '4'
training_try$HeatingQC[training_try$HeatingQC == 'Gd'] <- '3'
training_try$HeatingQC[training_try$HeatingQC == 'TA'] <- '2'
training_try$HeatingQC[training_try$HeatingQC == 'Fa'] <- '1'
training_try$HeatingQC[training_try$HeatingQC == 'Po'] <- '0'
training_try$HeatingQC<-as.numeric(training_try$HeatingQC)

# Transform Functional into numeric
training_try$Functional <- sapply(training_try$Functional, as.character)
training_try$Functional[training_try$Functional == 'Typ'] <- '0'
training_try$Functional[training_try$Functional == 'Min1' | training_try$Functional == 'Min2'] <- '1'
training_try$Functional[training_try$Functional == 'Mod'] <- '2'
training_try$Functional[training_try$Functional == 'Maj1' | training_try$Functional == 'Maj2'] <- '3'
training_try$Functional[training_try$Functional == 'Sev'] <- '4'
training_try$Functional[training_try$Functional == 'Sal'] <- '5'
training_try$Functional<-as.numeric(training_try$Functional)

# Transform FireplaceQu into numeric
training_try$FireplaceQu <- sapply(training_try$FireplaceQu, as.character)
training_try$FireplaceQu[training_try$FireplaceQu == 'Ex'] <- '5'
training_try$FireplaceQu[training_try$FireplaceQu == 'Gd'] <- '4'
training_try$FireplaceQu[training_try$FireplaceQu == 'TA'] <- '3'
training_try$FireplaceQu[training_try$FireplaceQu == 'Fa'] <- '2'
training_try$FireplaceQu[training_try$FireplaceQu == 'Po'] <- '1'
training_try$FireplaceQu[training_try$FireplaceQu == 'No'] <- '0'
training_try$FireplaceQu<-as.numeric(training_try$FireplaceQu)

# Whether or not the house has a garage
training_try$GarageType <- sapply(training_try$GarageType, as.character)
training_try$GarageType[training_try$GarageType == 'No'] <- '0'
training_try$GarageType[training_try$GarageType != '0'] <- '1'
training_try$GarageType<-as.numeric(training_try$GarageType)

# Transform GarageFinish into numeric
training_try$GarageFinish <- sapply(training_try$GarageFinish, as.character)
training_try$GarageFinish[training_try$GarageFinish == 'Fin'] <- '3'
training_try$GarageFinish[training_try$GarageFinish == 'RFn'] <- '2'
training_try$GarageFinish[training_try$GarageFinish == 'Unf'] <- '1'
training_try$GarageFinish[training_try$GarageFinish == 'No'] <- '0'
training_try$GarageFinish<-as.numeric(training_try$GarageFinish)

# Transform GarageQual into numeric
training_try$GarageQual <- sapply(training_try$GarageQual, as.character)
training_try$GarageQual[training_try$GarageQual == 'Ex'] <- '5'
training_try$GarageQual[training_try$GarageQual == 'Gd'] <- '4'
training_try$GarageQual[training_try$GarageQual == 'TA'] <- '3'
training_try$GarageQual[training_try$GarageQual == 'Fa'] <- '2'
training_try$GarageQual[training_try$GarageQual == 'Po'] <- '1'
training_try$GarageQual[training_try$GarageQual == 'No'] <- '0'
training_try$GarageQual<-as.numeric(training_try$GarageQual)

# Creating of 2 new variables follows same intuition: good quality normally rises the price and bad quality usually lowers the price.
training_try$Good_GarageQual<- training_try$GarageQual
training_try$Good_GarageQual[training_try$Good_GarageQual >= 4] <- 1
training_try$Good_GarageQual[training_try$Good_GarageQual != 1] <- 0

training_try$Bad_GarageQual<- training_try$GarageQual
training_try$Bad_GarageQual[training_try$Bad_GarageQual != 1] <- 0

# Transform GarageCond into numeric
training_try$GarageCond <- sapply(training_try$GarageCond, as.character)
training_try$GarageCond[training_try$GarageCond == 'Ex'] <- '5'
training_try$GarageCond[training_try$GarageCond == 'Gd'] <- '4'
training_try$GarageCond[training_try$GarageCond == 'TA'] <- '3'
training_try$GarageCond[training_try$GarageCond == 'Fa'] <- '2'
training_try$GarageCond[training_try$GarageCond == 'Po'] <- '1'
training_try$GarageCond[training_try$GarageCond == 'No'] <- '0'
training_try$GarageCond<-as.numeric(training_try$GarageCond)

# Follows same intuition: good condition normally rises the price and bad condition usually lowers the price.
training_try$Good_GarageCond<- training_try$GarageCond
training_try$Good_GarageCond[training_try$Good_GarageCond >= 4] <- 1
training_try$Good_GarageCond[training_try$Good_GarageCond != 1] <- 0

training_try$Bad_GarageCond<- training_try$GarageCond
training_try$Bad_GarageCond[training_try$Bad_GarageCond != 1] <- 0

# Transform PoolQC into numeric
training_try$PoolQC <- sapply(training_try$PoolQC, as.character)
training_try$PoolQC[training_try$PoolQC == 'Ex'] <- '4'
training_try$PoolQC[training_try$PoolQC == 'Gd'] <- '3'
training_try$PoolQC[training_try$PoolQC == 'TA'] <- '2'
training_try$PoolQC[training_try$PoolQC == 'Fa'] <- '1'
training_try$PoolQC[training_try$PoolQC == 'No'] <- '0'
training_try$PoolQC<-as.numeric(training_try$PoolQC)

# Transform Fence into numeric
training_try$Fence <- sapply(training_try$Fence, as.character)
training_try$Fence[training_try$Fence == 'GdPrv' | training_try$Fence == 'GdWo'] <- '2'
training_try$Fence[training_try$Fence == 'MnPrv' | training_try$Fence == 'MnWw'] <- '1'
training_try$Fence[training_try$Fence != '2' | training_try$Fence != '1'] <- '0'
training_try$Fence<-as.numeric(training_try$Fence)

# Transform Foundation into numeric
# Market Research as well as plots were analyzed to categorize these types of foundation
training_try$Foundation <- sapply(training_try$Foundation, as.character)
training_try$Foundation[training_try$Foundation == 'PConc'] <- '6'
training_try$Foundation[training_try$Foundation == 'Wood'] <- '5'
training_try$Foundation[training_try$Foundation == 'Stone'] <- '4'
training_try$Foundation[training_try$Foundation == 'CBlock'] <- '3'
training_try$Foundation[training_try$Foundation == 'BrkTil'] <- '2'
training_try$Foundation[training_try$Foundation == 'Slab'] <- '1'
training_try$Foundation<-as.numeric(training_try$Foundation)
```

```{r Test Data transformations and creating new features}
# 2007-2009 were the house price declined due to the bubble.
# these years are separated from the others to account for their macroeconomic impact.
test_try<-test_data  
# test_try was originally created so that test_data remained intact in case of big errors. However, we will keep using it because otherwise there will be timing-consuming modifications on codes.

test_try$YearSold[test_try$YrSold == 2007 | test_try$YrSold == 2008 | test_try$YrSold == 2009] <- 1
test_try$YearSold[is.na(test_try$YearSold)] <- 0

# Porch and Pool are nice adds on to the house. The size probably will not matter as much
# The fact that a house has one of these matters
test_try$WoodDeckSF[test_try$WoodDeckSF != 0] <-1
test_try$OpenPorchSF[test_try$OpenPorchSF != 0] <-1
test_try$EnclosedPorch[test_try$EnclosedPorch != 0] <-1
test_try$X3SsnPorch[test_try$X3SsnPorch != 0] <-1
test_try$ScreenPorch[test_try$ScreenPorch != 0] <-1
test_try$PoolArea[test_try$PoolArea != 0] <-1

# Identifying the newer dwellings
test_try$Newer[test_try$MSSubClass == 20 | test_try$MSSubClass == 60 | test_try$MSSubClass == 120 | test_try$MSSubClass == 160] <- 1
test_try$Newer[is.na(test_try$Newer)] <- 0

# Numerical variables were created 
test_try$Street <- ifelse(test_try$Street %in% c('Grvl'), 1, 0)

test_try$Alley <- ifelse(test_try$Alley %in% c('Grvl' , 'Pave'), 1, 0)

test_try$LotShape <- ifelse(test_try$LotShape %in% c('Reg'), 1, 0)

test_try$PavedDrive <- ifelse(test_try$PavedDrive %in% c('Y' , 'P'), 1, 0)


#https://www.neighborhoodscout.com/ia/ames
test_try$Neighborhood <- ifelse(test_try$Neighborhood %in% c('NoRidge','NridgHt', 'StoneBr', 'SWISU', 'Somerst', 'Timber', 'Veenker'), 1, 0)


# Averaging the scores: overall quality and overall condition
test_try$OverallRate<- (test_try$OverallQual+test_try$OverallCond)/2

# Good rate and bad rate variables were created because it is believed that price increases with goo rate and decreases with a bad rate.
test_try$Good_Rate<- test_try$OverallRate
test_try$Good_Rate[test_try$Good_Rate >= 8] <- 1
test_try$Good_Rate[test_try$Good_Rate != 1] <- 0

test_try$Bad_Rate<- test_try$OverallRate
test_try$Bad_Rate[test_try$Bad_Rate < 3] <- 1
test_try$Bad_Rate[test_try$Bad_Rate != 1] <- 0

# YearRemodAdd will express where or not a house has been remodelled. 
#Older but remodelled is believed to worth a bit more.
test_try$YearRemodAdd[test_try$YearRemodAdd == test_try$YearBuilt] <- 0
test_try$YearRemodAdd[test_try$YearRemodAdd != 0] <- 1

#ExterQual
test_try$ExterQual <- sapply(test_try$ExterQual, as.character)
test_try$ExterQual[test_try$ExterQual == 'Ex'] <- '5'
test_try$ExterQual[test_try$ExterQual == 'Gd'] <- '4'
test_try$ExterQual[test_try$ExterQual == 'TA'] <- '3'
test_try$ExterQual[test_try$ExterQual == 'Fa'] <- '2'
test_try$ExterQual[test_try$ExterQual == 'Po'] <- '1'
test_try$ExterQual<-as.numeric(test_try$ExterQual)

test_try$Good_ExterQual<- test_try$ExterQual
test_try$Good_ExterQual[test_try$Good_ExterQual >= 4] <- 1
test_try$Good_ExterQual[test_try$Good_ExterQual != 1] <- 0

test_try$Bad_ExterQual<- test_try$ExterQual
test_try$Bad_ExterQual[test_try$Bad_ExterQual != 1] <- 0

#ExterCond
test_try$ExterCond <- sapply(test_try$ExterCond, as.character)
test_try$ExterCond[test_try$ExterCond == 'Ex'] <- '5'
test_try$ExterCond[test_try$ExterCond == 'Gd'] <- '4'
test_try$ExterCond[test_try$ExterCond == 'TA'] <- '3'
test_try$ExterCond[test_try$ExterCond == 'Fa'] <- '2'
test_try$ExterCond[test_try$ExterCond == 'Po'] <- '1'
test_try$ExterCond<-as.numeric(test_try$ExterCond)

test_try$Good_ExterCond<- test_try$ExterCond
test_try$Good_ExterCond[test_try$Good_ExterCond >= 4] <- 1
test_try$Good_ExterCond[test_try$Good_ExterCond != 1] <- 0

test_try$Bad_ExterCond<- test_try$ExterCond
test_try$Bad_ExterCond[test_try$Bad_ExterCond != 1] <- 0

#BsmtQual
test_try$BsmtQual <- sapply(test_try$BsmtQual, as.character)
test_try$BsmtQual[test_try$BsmtQual == 'Ex'] <- '5'
test_try$BsmtQual[test_try$BsmtQual == 'Gd'] <- '4'
test_try$BsmtQual[test_try$BsmtQual == 'TA'] <- '3'
test_try$BsmtQual[test_try$BsmtQual == 'Fa'] <- '2'
test_try$BsmtQual[test_try$BsmtQual == 'Po'] <- '1'
test_try$BsmtQual[test_try$BsmtQual == 'No'] <- '0'
test_try$BsmtQual<-as.numeric(test_try$BsmtQual)

test_try$Good_BsmtQual<- test_try$BsmtQual
test_try$Good_BsmtQual[test_try$Good_BsmtQual >= 4] <- 1
test_try$Good_BsmtQual[test_try$Good_BsmtQual != 1] <- 0

test_try$Bad_BsmtQual<- test_try$BsmtQual
test_try$Bad_BsmtQual[test_try$Bad_BsmtQual != 1] <- 0

#BsmtCond
test_try$BsmtCond <- sapply(test_try$BsmtCond, as.character)
test_try$BsmtCond[test_try$BsmtCond == 'Ex'] <- '5'
test_try$BsmtCond[test_try$BsmtCond == 'Gd'] <- '4'
test_try$BsmtCond[test_try$BsmtCond == 'TA'] <- '3'
test_try$BsmtCond[test_try$BsmtCond == 'Fa'] <- '2'
test_try$BsmtCond[test_try$BsmtCond == 'Po'] <- '1'
test_try$BsmtCond[test_try$BsmtCond == 'No'] <- '0'
test_try$BsmtCond<-as.numeric(test_try$BsmtCond)

test_try$Good_BsmtCond<- test_try$BsmtCond
test_try$Good_BsmtCond[test_try$Good_BsmtCond >= 4] <- 1
test_try$Good_BsmtCond[test_try$Good_BsmtCond != 1] <- 0

test_try$Bad_BsmtCond<- test_try$BsmtCond
test_try$Bad_BsmtCond[test_try$Bad_BsmtCond != 1] <- 0

#BsmtExposure
test_try$BsmtExposure <- sapply(test_try$BsmtExposure, as.character)
test_try$BsmtExposure[test_try$BsmtExposure == 'Gd'] <- '3'
test_try$BsmtExposure[test_try$BsmtExposure == 'Av'] <- '2'
test_try$BsmtExposure[test_try$BsmtExposure == 'Mn'] <- '1'
test_try$BsmtExposure[test_try$BsmtExposure == 'No'] <- '0'
test_try$BsmtExposure<-as.numeric(test_try$BsmtExposure)

#BsmtFinType1
test_try$BsmtFinType1 <- sapply(test_try$BsmtFinType1, as.character)
test_try$BsmtFinType1[test_try$BsmtFinType1 == 'GLQ'] <- '3'
test_try$BsmtFinType1[test_try$BsmtFinType1 == 'ALQ' | test_try$BsmtFinType1 == 'Rec'] <- '2'
test_try$BsmtFinType1[test_try$BsmtFinType1 == 'BLQ'] <- '1'
test_try$BsmtFinType1[test_try$BsmtFinType1 == 'LwQ' | test_try$BsmtFinType1 == 'Unf' | test_try$BsmtFinType1 == 'No'] <- '0'
test_try$BsmtFinType1<-as.numeric(test_try$BsmtFinType1)

#BsmtFinType2
test_try$BsmtFinType2 <- sapply(test_try$BsmtFinType2, as.character)
test_try$BsmtFinType2[test_try$BsmtFinType2 == 'GLQ'] <- '3'
test_try$BsmtFinType2[test_try$BsmtFinType2 == 'ALQ' | test_try$BsmtFinType2 == 'Rec'] <- '2'
test_try$BsmtFinType2[test_try$BsmtFinType2 == 'BLQ'] <- '1'
test_try$BsmtFinType2[test_try$BsmtFinType2 == 'LwQ' | test_try$BsmtFinType2 == 'Unf' | test_try$BsmtFinType2 == 'No'] <- '0'
test_try$BsmtFinType2<-as.numeric(test_try$BsmtFinType2)

#CentralAir
test_try$CentralAir <- sapply(test_try$CentralAir, as.character)
test_try$CentralAir[test_try$CentralAir == 'Y'] <- '1'
test_try$CentralAir[test_try$CentralAir == 'N'] <- '0'
test_try$CentralAir<-as.numeric(test_try$CentralAir)

#KitchenQual
test_try$KitchenQual <- sapply(test_try$KitchenQual, as.character)
test_try$KitchenQual[test_try$KitchenQual == 'Ex'] <- '4'
test_try$KitchenQual[test_try$KitchenQual == 'Gd'] <- '3'
test_try$KitchenQual[test_try$KitchenQual == 'TA'] <- '2'
test_try$KitchenQual[test_try$KitchenQual == 'Fa'] <- '1'
test_try$KitchenQual[test_try$KitchenQual == 'Po'] <- '0'
test_try$KitchenQual<-as.numeric(test_try$KitchenQual)

test_try$Good_KitchenQual<- test_try$BsmtCond
test_try$Good_KitchenQual[test_try$Good_BsmtCond >= 3] <- 1
test_try$Good_KitchenQual[test_try$Good_BsmtCond != 1] <- 0

test_try$Bad_KitchenQual<- test_try$KitchenQual
test_try$Bad_KitchenQual[test_try$Bad_KitchenQual != 1] <- 0


#HeatingQC
test_try$HeatingQC <- sapply(test_try$HeatingQC, as.character)
test_try$HeatingQC[test_try$HeatingQC == 'Ex'] <- '4'
test_try$HeatingQC[test_try$HeatingQC == 'Gd'] <- '3'
test_try$HeatingQC[test_try$HeatingQC == 'TA'] <- '2'
test_try$HeatingQC[test_try$HeatingQC == 'Fa'] <- '1'
test_try$HeatingQC[test_try$HeatingQC == 'Po'] <- '0'
test_try$HeatingQC<-as.numeric(test_try$HeatingQC)


#Functional
test_try$Functional <- sapply(test_try$Functional, as.character)
test_try$Functional[test_try$Functional == 'Typ'] <- '0'
test_try$Functional[test_try$Functional == 'Min1' | test_try$Functional == 'Min2'] <- '1'
test_try$Functional[test_try$Functional == 'Mod'] <- '2'
test_try$Functional[test_try$Functional == 'Maj1' | test_try$Functional == 'Maj2'] <- '3'
test_try$Functional[test_try$Functional == 'Sev'] <- '4'
test_try$Functional[test_try$Functional == 'Sal'] <- '5'
test_try$Functional<-as.numeric(test_try$Functional)

#FireplaceQu
test_try$FireplaceQu <- sapply(test_try$FireplaceQu, as.character)
test_try$FireplaceQu[test_try$FireplaceQu == 'Ex'] <- '5'
test_try$FireplaceQu[test_try$FireplaceQu == 'Gd'] <- '4'
test_try$FireplaceQu[test_try$FireplaceQu == 'TA'] <- '3'
test_try$FireplaceQu[test_try$FireplaceQu == 'Fa'] <- '2'
test_try$FireplaceQu[test_try$FireplaceQu == 'Po'] <- '1'
test_try$FireplaceQu[test_try$FireplaceQu == 'No'] <- '0'
test_try$FireplaceQu<-as.numeric(test_try$FireplaceQu)

# Whether or not the house has a garage
test_try$GarageType <- sapply(test_try$GarageType, as.character)
test_try$GarageType[test_try$GarageType == 'No'] <- '0'
test_try$GarageType[test_try$GarageType != '0'] <- '1'
test_try$GarageType<-as.numeric(test_try$GarageType)

#GarageFinish
test_try$GarageFinish <- sapply(test_try$GarageFinish, as.character)
test_try$GarageFinish[test_try$GarageFinish == 'Fin'] <- '3'
test_try$GarageFinish[test_try$GarageFinish == 'RFn'] <- '2'
test_try$GarageFinish[test_try$GarageFinish == 'Unf'] <- '1'
test_try$GarageFinish[test_try$GarageFinish == 'No'] <- '0'
test_try$GarageFinish<-as.numeric(test_try$GarageFinish)

#GarageQual
test_try$GarageQual <- sapply(test_try$GarageQual, as.character)
test_try$GarageQual[test_try$GarageQual == 'Ex'] <- '5'
test_try$GarageQual[test_try$GarageQual == 'Gd'] <- '4'
test_try$GarageQual[test_try$GarageQual == 'TA'] <- '3'
test_try$GarageQual[test_try$GarageQual == 'Fa'] <- '2'
test_try$GarageQual[test_try$GarageQual == 'Po'] <- '1'
test_try$GarageQual[test_try$GarageQual == 'No'] <- '0'
test_try$GarageQual<-as.numeric(test_try$GarageQual)

test_try$Good_GarageQual<- test_try$GarageQual
test_try$Good_GarageQual[test_try$Good_GarageQual >= 4] <- 1
test_try$Good_GarageQual[test_try$Good_GarageQual != 1] <- 0

test_try$Bad_GarageQual<- test_try$GarageQual
test_try$Bad_GarageQual[test_try$Bad_GarageQual != 1] <- 0

#GarageCond
test_try$GarageCond <- sapply(test_try$GarageCond, as.character)
test_try$GarageCond[test_try$GarageCond == 'Ex'] <- '5'
test_try$GarageCond[test_try$GarageCond == 'Gd'] <- '4'
test_try$GarageCond[test_try$GarageCond == 'TA'] <- '3'
test_try$GarageCond[test_try$GarageCond == 'Fa'] <- '2'
test_try$GarageCond[test_try$GarageCond == 'Po'] <- '1'
test_try$GarageCond[test_try$GarageCond == 'No'] <- '0'
test_try$GarageCond<-as.numeric(test_try$GarageCond)

test_try$Good_GarageCond<- test_try$GarageCond
test_try$Good_GarageCond[test_try$Good_GarageCond >= 4] <- 1
test_try$Good_GarageCond[test_try$Good_GarageCond != 1] <- 0

test_try$Bad_GarageCond<- test_try$GarageCond
test_try$Bad_GarageCond[test_try$Bad_GarageCond != 1] <- 0


#PoolQC
test_try$PoolQC <- sapply(test_try$PoolQC, as.character)
test_try$PoolQC[test_try$PoolQC == 'Ex'] <- '4'
test_try$PoolQC[test_try$PoolQC == 'Gd'] <- '3'
test_try$PoolQC[test_try$PoolQC == 'TA'] <- '2'
test_try$PoolQC[test_try$PoolQC == 'Fa'] <- '1'
test_try$PoolQC[test_try$PoolQC == 'No'] <- '0'
test_try$PoolQC<-as.numeric(test_try$PoolQC)

#Fence
test_try$Fence <- sapply(test_try$Fence, as.character)
test_try$Fence[test_try$Fence == 'GdPrv' | test_try$Fence == 'GdWo'] <- '2'
test_try$Fence[test_try$Fence == 'MnPrv' | test_try$Fence == 'MnWw'] <- '1'
test_try$Fence[test_try$Fence != '2' | test_try$Fence != '1'] <- '0'
test_try$Fence<-as.numeric(test_try$Fence)

#Foundation
test_try$Foundation <- sapply(test_try$Foundation, as.character)
test_try$Foundation[test_try$Foundation == 'PConc'] <- '6'
test_try$Foundation[test_try$Foundation == 'Wood'] <- '5'
test_try$Foundation[test_try$Foundation == 'Stone'] <- '4'
test_try$Foundation[test_try$Foundation == 'CBlock'] <- '3'
test_try$Foundation[test_try$Foundation == 'BrkTil'] <- '2'
test_try$Foundation[test_try$Foundation == 'Slab'] <- '1'
test_try$Foundation<-as.numeric(test_try$Foundation)
```


#Train and Validation Dataset split
```{r Train test split}
# Training and Validation data are split into 75% and 25% of the training_data
splitdf <- function(dataframe, seed=NULL, percentage=0.75) {
  if (!is.null(seed)) set.seed(seed)
  index <- 1:nrow(dataframe)
  trainingsample <- round(length(index) * percentage)
  trainindex <- sample(index, trainingsample)
  trainset <- dataframe[trainindex, ]
  testset <- dataframe[-trainindex, ]
  list(trainset=trainset,testset=testset)
}

splits <- splitdf(training_try, seed=123)
training = splits$trainset
validation = splits$testset
```


```{r Chi-Squared}
# Chi-squared is used to identify and pre-select valuable features
weights<- data.frame(chi.squared(SalePrice~., training))
weights$feature <- rownames(weights)
weights[order(weights$attr_importance, decreasing = TRUE),]
chi_squared_features <- weights$feature[weights$attr_importance >= 0.1]
```

Did the same process for information gain features; however, the results for worse.

#Lasso Regression with Chi-squared features
```{r}
training_lasso <- training[append(chi_squared_features, "SalePrice")]
validation_lasso <- validation[append(chi_squared_features, "SalePrice")]
lambdas <- 10^seq(-15,10, by=1/3)
lambdas
lasso.cv_fit <- cv.glmnet(x = data.matrix(training_lasso[,-ncol(training_lasso)]), y=training_lasso$SalePrice, alpha = 1, lambda = lambdas)
plot(lasso.cv_fit)
```
Feedback: should have trained the model with the whole training data instead of just the training_lasso.

```{r}
bestlam <- lasso.cv_fit$lambda.min
paste("Best Lambda value from CV=", bestlam)
lasso.mod <- glmnet(x = data.matrix(training_lasso[,-ncol(training_lasso)]), y=training_lasso$SalePrice, alpha = 1, lambda = lambdas)
lasso.pred=predict(lasso.mod, s=bestlam, data.matrix(validation_lasso[,-ncol(validation_lasso)]))
paste("RMSE for lambda ", bestlam, " = ", sqrt(mean((lasso.pred - validation_lasso$SalePrice)^2)))
```

```{r}
lam1se <- lasso.cv_fit$lambda.1se
paste("Lambda 1se value from CV=", lam1se)
lasso.mod <- glmnet(x = data.matrix(training_lasso[,-ncol(training_lasso)]), y=training$SalePrice, alpha = 1, lambda = lambdas)
lasso.pred=predict(lasso.mod, s=lam1se, data.matrix(validation_lasso[,-ncol(validation_lasso)]))
paste("RMSE for lambda ", lam1se, " = ", sqrt(mean((lasso.pred - validation_lasso$SalePrice)^2)))
```


```{r}
my_data=as.data.frame(cbind(predicted=lasso.pred,observed=validation$SalePrice))

ggplot(my_data,aes(my_data["1"],observed))+
  geom_point()+geom_smooth(method="lm")+
  scale_x_continuous(expand = c(0,0)) +
  labs(x="Predicted") +
  ggtitle('Lasso')
```

#Variable Importance
```{r}
imp <- varImp(lasso.mod, lambda = bestlam)
names <- rownames(imp)[order(imp$Overall, decreasing=TRUE)]
importance <- imp[names,]

data.frame(row.names = names, importance)
```


```{r}
filtered_names <- rownames(imp)[order(imp$Overall, decreasing=TRUE)][1:28]
print(filtered_names)
```

#Prediction on test data set
```{r}
log_prediction <- predict(lasso.cv_fit,  s=lasso.cv_fit$lambda.min, newx = data.matrix(test_try[chi_squared_features]))
actual_pred <- exp(log_prediction)-1
hist(actual_pred)
submit <- data.frame(Id=test_data$Id,SalePrice=actual_pred)
colnames(submit) <-c("Id", "SalePrice")

submit$SalePrice[is.na(submit$SalePrice)] <- 0
replace_value_for_na <- sum(na.omit(submit$SalePrice))/(nrow(submit) - sum(submit$SalePrice == 0))
submit$SalePrice[submit$SalePrice == 0] <- replace_value_for_na

write.csv(submit,file="lasso_final.csv",row.names=F)
```

